// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var MongoDB, Rserver, Rsocket, async, checkToken, cookie, crypto, moduleOptions, sockjs, winston;

  sockjs = require('sockjs');

  Rsocket = require("./lib/socket");

  Rserver = require("./lib/server");

  crypto = require('crypto');

  cookie = require('cookie');

  winston = require('winston');

  MongoDB = require('winston-mongodb').MongoDB;

  async = require('async');

  moduleOptions = {};

  checkToken = function(token, cb) {
    var redisClient;
    if (typeof cb !== 'function') {
      cb = function() {};
    }
    redisClient = moduleOptions.redis.client;
    return redisClient.get(token, function(err, result) {
      if (err) {
        return cb(err);
      }
      if (!result) {
        return cb(null, false);
      }
      return cb(null, result);
    });
  };

  module.exports = {
    configure: function(options) {
      if (options) {
        return moduleOptions = options;
      }
    },
    authenticate: function(req, res, next) {
      var hash, key, redis, sessionField, sessionFieldName;
      hash = crypto.createHash('sha1');
      hash.update(moduleOptions.auth.secret);
      hash.update('' + (new Date).getTime());
      key = hash.digest('hex');
      res.cookie(moduleOptions.auth.key, key);
      redis = moduleOptions.redis.client;
      sessionFieldName = moduleOptions.auth.sessionField;
      if (req.session.passport) {
        sessionField = req.session.passport[sessionFieldName];
      } else {
        sessionField = req.session[sessionFieldName];
      }
      if (sessionField) {
        redis.set(key, sessionField);
      }
      return next();
    },
    createLogger: function(options) {
      var logFile, logger, transports;
      options = options || {};
      transports = [
        new winston.transports.Console(), new MongoDB({
          level: 'info',
          db: 'rootty_logs',
          collection: 'rsocket'
        })
      ];
      logFile = options.file;
      if (logFile) {
        transports.push(new winston.transports.File({
          filename: logFile,
          maxsize: 1024 * 1000,
          maxFiles: 30
        }));
      }
      return logger = new winston.Logger({
        transports: transports
      });
    },
    createServer: function(httpServer, cb) {
      var logger;
      if (typeof cb === 'undefined') {
        cb = httpServer;
        httpServer = false;
      }
      logger = this.createLogger(moduleOptions.log);
      return async.waterfall([
        (function(_this) {
          return function(next) {
            var db, redisClient, redisOptions;
            redisOptions = moduleOptions.redis;
            db = redisOptions.clientDb;
            redisClient = redisOptions.client;
            return redisClient.select(db, function(err, result) {
              var rserver;
              if (err) {
                return next(err);
              }
              rserver = new Rserver({
                redis: {
                  client: redisClient,
                  sub: redisOptions.sub,
                  pub: redisOptions.pub
                }
              });
              rserver.logger = logger;
              return next(null, rserver);
            });
          };
        })(this), (function(_this) {
          return function(rserver, next) {
            var onOriginalConnection, sockjsOptions;
            if (!httpServer) {
              console.log('Virtual sockets only.');
              return next(null, rserver);
            }
            console.log('Listen real sockets.');
            rserver.clientRedis.flushdb();
            sockjsOptions = moduleOptions.socket;
            _this.sockjsServer = sockjs.createServer(sockjsOptions);
            onOriginalConnection = function(conn) {
              var rsocket;
              rsocket = new Rsocket(conn, rserver);
              rserver.addSocket(rsocket);
              return rsocket.conn.once('data', function(cookies) {
                var authKey;
                cookies = cookie.parse(cookies);
                authKey = cookies[moduleOptions.auth.key];
                return checkToken(cookies[moduleOptions.auth.key], function(err, result) {
                  if (err) {
                    logger.error(err);
                    throw new Error(err);
                  }
                  if (result) {
                    logger.info('AUTH SUCCESS', {
                      authKey: authKey,
                      socket: rsocket.id
                    });
                    rserver.activateSocket(rsocket, result);
                    return rserver.emit('connection', rsocket);
                  }
                  logger.info('AUTH FAILED', {
                    authKey: authKey,
                    socket: rsocket.id
                  });
                  return rsocket.conn.close(403, 'Not authorized');
                });
              });
            };
            _this.sockjsServer.on('connection', onOriginalConnection);
            _this.sockjsServer.installHandlers(httpServer);
            return next(null, rserver);
          };
        })(this)
      ], function(err, rserver) {
        if (err) {
          logger.error(err);
          throw new Error(err);
        }
        return cb(rserver);
      });
    }
  };

}).call(this);
