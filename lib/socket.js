// Generated by CoffeeScript 1.7.1
(function() {
  "user strict";
  var Socket, events, util, _;

  util = require('util');

  events = require('events');

  _ = require('lodash');

  Socket = function(conn, server) {
    this.conn = conn;
    this.server = server;
    this.id = this.conn.id;
    this._emit = this.emit;
    this.rooms = [];
    this.session = {};
    this.onElapsedTime = function(socket) {
      socket.server.logger.warn('Time elapsed for %s and socket %s', socket.session, socket.id, {
        session: socket.session,
        socket: socket.id,
        conn_id: socket.conn.id
      });
      return socket.conn.close(408, 'Ping timeout');
    };
    this._updateTimeout = function() {
      if (this.pingTimeout) {
        clearTimeout(this.pingTimeout);
      }
      return this.pingTimeout = setTimeout(this.onElapsedTime, 60 * 1000, this);
    };
    this._onConnectionData = (function(_this) {
      return function(message) {
        var args;
        _this._updateTimeout();
        if (message === 'ping:request') {
          return false;
        }
        message = _this._parseMessage(message);
        args = [message.label].concat(message.data);
        return _this._emit.apply(_this, args);
      };
    })(this);
    this._onDisconnect = (function(_this) {
      return function() {
        if (_this.pingTimeout) {
          clearTimeout(_this.pingTimeout);
        }
        return _this._leaveRooms(_this.rooms, function(err, replies) {
          if (err) {
            throw new Error;
          }
          _this._emit('disconnect');
          return _this.server.logger.info('DISCONNECT', {
            session: _this.session,
            socket: _this.id
          });
        });
      };
    })(this);
    this._leaveRooms = function(rooms, done) {
      var room, transaction, _i, _len;
      transaction = this.server.clientRedis.multi();
      for (_i = 0, _len = rooms.length; _i < _len; _i++) {
        room = rooms[_i];
        transaction.srem('room:' + room, this.id);
      }
      return transaction.exec(done);
    };
    this._parseMessage = function(message) {
      message = JSON.parse(message);
      return {
        label: message._label,
        data: message.data
      };
    };
    this._generateMessage = function(label, data) {
      return JSON.stringify({
        _label: label,
        data: data
      });
    };
    this.emit = function(label, args) {
      var arg, i, message, _i, _len;
      if (arguments.length > 2) {
        args = [];
        for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {
          arg = arguments[i];
          if (i !== 0) {
            args.push(arg);
          }
        }
      }
      message = this._generateMessage(label, args);
      return this.conn.write(message);
    };
    this.join = (function(_this) {
      return function(room) {
        return _this.server.addToRoom(_this, room);
      };
    })(this);
    this.leave = (function(_this) {
      return function(room) {
        return _this.server.removeFromRoom(_this, room);
      };
    })(this);
    this.leaveByReg = (function(_this) {
      return function(reg, done) {
        var matchedRooms, room, _i, _len, _ref;
        matchedRooms = [];
        _ref = _this.rooms;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          room = _ref[_i];
          if (reg.test(room)) {
            matchedRooms.push(room);
          }
        }
        return _this._leaveRooms(matchedRooms, function(err, replies) {
          if (err) {
            return done(err);
          }
          _this.rooms = _.difference(_this.rooms, matchedRooms);
          return done(null, matchedRooms);
        });
      };
    })(this);
    this._activate = (function(_this) {
      return function(sessionData) {
        _this.session = sessionData || {};
        _this.conn.on('data', _this._onConnectionData);
        return _this._updateTimeout();
      };
    })(this);
    this.conn.on('close', this._onDisconnect);
    return this;
  };

  util.inherits(Socket, events.EventEmitter);

  module.exports = Socket;

}).call(this);
